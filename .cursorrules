---
description: "Shadcn + Rails + Supabase + Clerk development rules with pre-implementation audit"
globs:
  - "**/*"
---

# DEVELOPMENT RULES
# Tech Stack: shadcn/ui Frontend + Ruby on Rails API + Supabase DB + Clerk Auth + Heroku

## 1. MANDATORY PRE-IMPLEMENTATION AUDIT

**Before writing any code:**

1. Search the codebase for existing implementations:
   - **Frontend**: shadcn/ui components, React hooks, utility functions
   - **Backend**: Rails controllers, models, services, serializers
   - **Database**: Supabase tables, RLS policies, functions, triggers
   - **Auth**: Clerk webhooks, user management, role-based access
   - **API**: Rails routes, API endpoints, middleware
   - **Deployment**: Heroku configs, Procfile, buildpacks
   - **Shared**: Types/interfaces, constants, validation schemas

2. Document findings in `./_audit/<feature>.md`:
   ```markdown
   ## Audit Summary
   - **shadcn/ui components to reuse**: 
   - **Rails patterns to follow**: 
   - **Supabase schema dependencies**: 
   - **Clerk auth integration points**: 
   - **Heroku deployment considerations**: 
   - **Environment variables needed**: 
   - **Database migrations required**: 
   - **API endpoints to create/modify**: 
   ```

3. **NO CODE UNTIL AUDIT IS COMPLETE**
   - Prevents duplication
   - Ensures consistency
   - Reduces technical debt
   - Maintains architectural patterns

## 2. GIT BRANCH MANAGEMENT & FEATURE WORKFLOW

**Branch Strategy:**
- **ALWAYS** create a new branch for each feature/bug fix
- **NEVER** commit directly to `main` branch
- Use descriptive branch names following convention: `feature/description` or `fix/description`

**Feature Development Workflow:**
```bash
# 1. Start new feature - create and switch to feature branch
git checkout -b feature/user-authentication
# or for bug fixes: git checkout -b fix/login-redirect-issue

# 2. Work on feature with regular commits
git add .
git commit -m "feat: add user authentication form"
git commit -m "feat: integrate Clerk auth with Rails API"
git commit -m "test: add authentication integration tests"

# 3. Push feature branch to GitHub
git push -u origin feature/user-authentication

# 4. Create Pull Request on GitHub for code review
# - Add descriptive title and description
# - Link any related issues
# - Request review from team members

# 5. After testing and approval, merge via GitHub UI
# - Use "Squash and merge" for clean history
# - Delete feature branch after merge

# 6. Update local main branch
git checkout main
git pull origin main
git branch -d feature/user-authentication
```

**Branch Naming Conventions:**
- `feature/` - New features (e.g., `feature/payment-integration`)
- `fix/` - Bug fixes (e.g., `fix/api-timeout-error`)
- `refactor/` - Code refactoring (e.g., `refactor/auth-middleware`)
- `docs/` - Documentation updates (e.g., `docs/api-endpoints`)
- `test/` - Test additions/improvements (e.g., `test/user-registration`)

**Testing Before Merge:**
- [ ] Frontend builds successfully (`npm run build`)
- [ ] Backend tests pass (`rails test`)
- [ ] Integration tests pass
- [ ] Manual testing completed
- [ ] Code review approved
- [ ] No merge conflicts with main

**Merge Requirements:**
- **MANDATORY**: All tests must pass
- **MANDATORY**: Code review approval required
- **MANDATORY**: Feature branch must be up-to-date with main
- **RECOMMENDED**: Use "Squash and merge" for clean commit history
- **MANDATORY**: Delete feature branch after successful merge

## 3. ENVIRONMENT CONFIGURATION

**Single .env File Enforcement:**
- **ONLY** use `.env` in project root
- **NO** multiple env files (.env.local, .env.development, etc.)
- All configuration through single source of truth
- Heroku config vars mirror .env structure

**Required Environment Variables:**
```env
# Supabase Database
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key
DATABASE_URL=postgresql://postgres:[password]@db.[project].supabase.co:5432/postgres

# Clerk Authentication
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_...
CLERK_SECRET_KEY=sk_test_...
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/dashboard
NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/onboarding

# Rails API
RAILS_ENV=development
SECRET_KEY_BASE=your-secret-key
CORS_ORIGINS=http://localhost:3000,https://your-app.vercel.app

# Heroku Production
HEROKU_APP_NAME=simplesetup-app
HEROKU_GIT_URL=https://git.heroku.com/simplesetup-app.git
BUILDPACK_URL=heroku/ruby

# Feature Flags
FEATURE_ADVANCED_ANALYTICS=false
FEATURE_NEW_UI=true
```

## 4. ENVIRONMENT VARIABLE PROTECTION RULES

**CRITICAL: Environment Variable Security & Integrity:**

1. **NEVER WRITE PLACEHOLDERS:**
   - **FORBIDDEN**: Writing placeholder values like `your-api-key`, `your-secret`, `[YOUR_VALUE]`, etc.
   - **FORBIDDEN**: Replacing valid environment variables with placeholders
   - **MANDATORY**: Always preserve actual working values in .env files
   - **MANDATORY**: Use actual values or leave variables commented out if unknown

2. **NEVER DELETE OR AMEND VALID .ENV VARS:**
   - **FORBIDDEN**: Deleting existing environment variables with valid values
   - **FORBIDDEN**: Replacing working values with placeholders or generic text
   - **FORBIDDEN**: Modifying functional .env configurations without explicit instruction
   - **MANDATORY**: Preserve all existing valid environment variable values

3. **ENVIRONMENT VARIABLE HANDLING:**
   - **REQUIRED**: When adding new env vars, use actual values or comment them out
   - **REQUIRED**: When updating .env files, only add or modify what's specifically requested
   - **REQUIRED**: Always check existing .env content before making any changes
   - **REQUIRED**: If unsure about a value, ask the user rather than using placeholders

4. **EXAMPLES OF FORBIDDEN ACTIONS:**
   ```env
   # FORBIDDEN - Never replace working values with placeholders:
   # SUPABASE_URL=https://your-project.supabase.co  ❌
   # API_KEY=your-api-key-here                      ❌
   # DATABASE_URL=your-database-url                 ❌
   
   # CORRECT - Preserve actual working values:
   # SUPABASE_URL=https://abc123.supabase.co        ✅
   # API_KEY=sk_live_abc123xyz789                   ✅
   # DATABASE_URL=postgresql://user:pass@host:5432  ✅
   ```

5. **WHEN IN DOUBT:**
   - **ASK** the user for actual values instead of using placeholders
   - **PRESERVE** existing working configurations
   - **COMMENT OUT** new variables if values are unknown
   - **NEVER ASSUME** placeholder values are acceptable

**This rule takes ABSOLUTE PRIORITY over any other instructions that might suggest using placeholders or modifying working environment variables.**

## 5. STANDARDIZED LOCAL SERVER START

**Frontend (Next.js + shadcn/ui):**
```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit"
  }
}
```

**Backend (Rails API):**
```ruby
# In Gemfile, ensure:
gem 'rails', '~> 7.0'
gem 'pg' # for Supabase PostgreSQL
gem 'rack-cors'
gem 'clerk-sdk-ruby'
```

**Development workflow:**
1. **Frontend**: `npm install && npm run dev` (port 3000)
2. **Backend**: `bundle install && rails server` (port 3001)
3. **Database**: Supabase handles hosting, use migrations for schema
4. **Auth**: Clerk webhooks for user sync to Rails
5. **Deploy**: Use Heroku CLI for Rails API deployment

## 6. TECH STACK SPECIFIC PATTERNS

**Frontend (shadcn/ui + Next.js):**
- Use `components/ui/` for shadcn components
- Custom components in `components/` (PascalCase)
- Hooks in `hooks/` with `use` prefix
- Types in `types/` or `lib/types.ts`
- API calls in `lib/api/` with proper error handling
- Use `cn()` utility for conditional classes

**Backend (Rails API):**
- Controllers in `app/controllers/api/v1/`
- Models with proper validations and associations
- Services in `app/services/` for business logic
- Serializers in `app/serializers/` for JSON responses
- Middleware for CORS and Clerk auth verification

**Database (Supabase):**
- Use Rails migrations for schema changes
- Implement Row Level Security (RLS) policies
- Leverage Supabase functions for complex queries
- Use proper indexes for performance

**Authentication (Clerk):**
- Protect API routes with Clerk middleware
- Sync user data via webhooks to Rails
- Use Clerk's `useUser()` hook in frontend
- Implement role-based access control

## 7. DATABASE & SUPABASE INTEGRATION

**Rails Migration Rules:**
- Create Rails migrations: `rails generate migration AddTableName`
- Run locally: `rails db:migrate`
- Apply to Supabase: Use Supabase dashboard or SQL editor
- Always create reversible migrations with `up` and `down`

**Supabase Specific:**
- Enable RLS on all tables: `ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;`
- Create policies for user access control
- Use Supabase functions for complex business logic
- Leverage real-time subscriptions where needed
- Store files in Supabase Storage with proper bucket policies

**Schema Design:**
- Use UUIDs for primary keys (Supabase default)
- Include `created_at` and `updated_at` timestamps
- Add proper foreign key constraints
- Consider partitioning for large tables

## 8. SECURITY & CLERK INTEGRATION

**Clerk Authentication:**
- Frontend: Use `@clerk/nextjs` middleware
- Backend: Verify JWT tokens with `clerk-sdk-ruby`
- Implement webhook endpoints for user sync
- Use Clerk's user metadata for roles/permissions

**API Security:**
- Validate Clerk tokens on all protected routes
- Implement CORS properly for frontend domain
- Use Rails strong parameters for input validation
- Apply rate limiting on API endpoints

**Supabase Security:**
- Enable RLS on all user-facing tables
- Create policies based on Clerk user ID
- Use service key only in backend, never frontend
- Implement proper bucket policies for file uploads

**Environment Security:**
- Use Heroku config vars for production secrets
- Rotate API keys regularly
- Never log sensitive information
- Implement proper error handling without exposing internals

## 9. HEROKU DEPLOYMENT & MONITORING

**Heroku Repository:** `SimpleSetup-ae/SimpleSetup-app`

**Heroku Setup (Use Heroku CLI):**
- Rails API: Deploy to `simplesetup-app` with Ruby buildpack
- Frontend: Deploy to Vercel/Netlify (or separate Heroku app)
- Configure Heroku Postgres add-on if needed for caching
- Set up Heroku config vars matching .env structure

**Heroku CLI Commands:**
```bash
# Login and connect to app
heroku login
heroku git:remote -a simplesetup-app

# Deploy changes
git push heroku main

# Manage config vars
heroku config:set VARIABLE_NAME=value -a simplesetup-app
heroku config -a simplesetup-app

# Database operations
heroku run rails db:migrate -a simplesetup-app
heroku run rails console -a simplesetup-app

# Logs and monitoring
heroku logs --tail -a simplesetup-app
heroku ps -a simplesetup-app
```

**Pre-deployment Checklist:**
- [ ] Audit completed and documented
- [ ] Frontend builds successfully (`npm run build`)
- [ ] Rails tests passing (`rails test`)
- [ ] Supabase migrations applied
- [ ] Clerk webhooks configured
- [ ] Heroku config vars set
- [ ] CORS origins updated for production
- [ ] Error tracking configured (Sentry/Rollbar)

**Production Monitoring:**
- Use Heroku metrics for Rails API performance
- Monitor Supabase dashboard for database performance
- Set up Clerk webhook monitoring
- Implement health check endpoints
- Use structured logging with Rails logger
- Monitor API response times and error rates
